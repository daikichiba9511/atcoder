# 逆元

足し算、引き算、掛け算の途中で積極的にあまりを求めてもいい

CPPでは逆元をとるたびにあまりをとった方が無難らしい。

オーバーフロー対策

CPPでは、あまりを求めた結果が負の数になったらその法を足した方がいい。

pythonではうまくいってるっぽい (mod/mod_try2)

割り算は難しい

## 逆元の求め方

メジャーな方法を２通り

- フェルマーの小定理
- 拡張ユークリッドの互除法

計算時間はどちらも$O(\log p)$

前者は法pが素数でないと使えない
後者は実装がやや複雑だが逆元存在条件を満たせば使える
フェルマーの小定理を用いたものより早い

### フェルマーの小定理

---
『フェルマーの小定理』

pを素数、aをpの倍数出ない整数として

$$a ^ {p-1} \equiv 1 (\text{mod p})$$

が成立する。

---

---

$$
a \times a ^ {p-2} \equiv 1 (\text{mod p})
$$

---

これは$a ^ {p-2}$が$a$の逆元であることを示している。

なので$a ^ {p-2} \equiv 1 (\text{mod p})$を計算すればいいが愚直にやると$O(p)$かかってしまう

## 拡張ユークリッドの互除法

---

$x$が$\text{mod p}$における$a$の逆元であるとは、

$$ax \equiv 1 \space (\text{mod p})$$

が成立するということ。これは$ax - 1$が$p$で割り切れることを意味している。

---

つまり

$ax + py = 1$を満たす整数$y$が成立すること


を意味している。


## 逆元が存在する条件

---

mod p での$a$の逆元が存在する条件は、pと$a$が互いに素であること

---

誤解

- pが素数でない時は、必ず逆元は存在しない
- pが素数の時は、必ず逆元が存在する

前者はpと$a$とが互いに素でありさえすればいい。
後者は$a$がpの倍数の時には逆元が存在しない。

## 二分累乗法

## 二項係数$_{n}C_{r}$

考え方は

- $1!, 2!, 3!, \cdots$
- $(1!) ^ {-1}, (2!) ^ {-1}, (3!) ^ {-1}, \cdots$

を前処理で計算しておいて

$_{n}C_{r} = \frac{n!}{r!(n-r)!} = (n!)(r!) ^ {-1} ((n-r)!) ^ {-1}$

を毎回計算する。

前処理は$O(n)$で毎回の二項係数の計算は$O(1)$

