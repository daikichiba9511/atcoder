# 最短経路問題

## ダイクストラ法

負の辺を含まない重みつきグラフの単一始点最短経路問題に対して使われる。

- 1. priority_queue(優先度キュー)を用意する。そこへ始点の情報とそこへの最短距離をpushする（pythonならappend)このとき最短距離順で情報がソートされるようにする

- 2. キューの先頭要素（最短距離が一番小さいもの）を取り出す

- 3. もし記録してある最短距離より取り出した要素に入っている距離情報の方が大きければ、ここで打ち切って先頭要素を取り出す操作に戻る(->2)

- 4. そこから移動できる頂点を走破し、最短距離が更新できるものであれば、距離を更新してその頂点への距離、頂点の情報をキューにpushする(pythonならappend)

- 5. キューが空になるまで2~4を繰り返

## ワーシャルフロイド法

動的計画法を使ってとく

`dp[k][i][j]:=０からk-1までの頂点を使ってiからjまで移動する時の最小コスト`

dp[0][i][j] は当然iからjまでの距離に等しい。（へんが存在しない時は∞）

d[k+1][i][j]を求めることを考える

もしiからjまでの最短経路がkを含まない場合dp[k+1][i][j] = dp[k][i][j]

k, i, jの順に回せばdp[V][i][j]はiからjまでの最短経路

```python
for k in range(V):
    for i in range(V):
        for j in range(V):
            dp[i][j] = min(dp[i][j], dp[i][j]+dp[k][j])
```

計算量は$O(V ^ {3})$

初期値の設定とこのDPだけで最短経路が決まる。

途中で２頂点間の辺の長さが変わるだけクエリがあっても計算量$O(V ^ {2})$でできる。

ワーシャル・フロイド法は負のコストの辺があっても対応できる。

## 経路復元

一般的に動的計画法の復元は

「Aー>Bという遷移が存在して実際にA->Bへの遷移を行った時の同じ結果がBに記録されている時、Bまでの遷移ルートの中にAが含まれているものが必ず存在する。」

## クラスカル法




## 参考

- [qiita 最短経路、ダイクストラ](https://qiita.com/ageprocpp/items/cdf67e828e1b09316f6e#%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95)

- [qiita pythonでの優先度付きキュー](https://qiita.com/ell/items/fe52a9eb9499b7060ed6)